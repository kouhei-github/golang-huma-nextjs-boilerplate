// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tenant_user.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addUserToTenant = `-- name: AddUserToTenant :one
INSERT INTO tenant_users (
    tenant_id, user_id, role
) VALUES (
    $1, $2, $3
)
RETURNING id, tenant_id, user_id, role, created_at, updated_at
`

type AddUserToTenantParams struct {
	TenantID int64          `json:"tenant_id"`
	UserID   int64          `json:"user_id"`
	Role     sql.NullString `json:"role"`
}

func (q *Queries) AddUserToTenant(ctx context.Context, arg AddUserToTenantParams) (TenantUser, error) {
	row := q.db.QueryRowContext(ctx, addUserToTenant, arg.TenantID, arg.UserID, arg.Role)
	var i TenantUser
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantUser = `-- name: GetTenantUser :one
SELECT id, tenant_id, user_id, role, created_at, updated_at FROM tenant_users
WHERE tenant_id = $1 AND user_id = $2
LIMIT 1
`

type GetTenantUserParams struct {
	TenantID int64 `json:"tenant_id"`
	UserID   int64 `json:"user_id"`
}

func (q *Queries) GetTenantUser(ctx context.Context, arg GetTenantUserParams) (TenantUser, error) {
	row := q.db.QueryRowContext(ctx, getTenantUser, arg.TenantID, arg.UserID)
	var i TenantUser
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantsByUser = `-- name: GetTenantsByUser :many
SELECT t.id, t.organization_id, t.name, t.subdomain, t.is_active, t.created_at, t.updated_at FROM tenants t
INNER JOIN tenant_users tu ON t.id = tu.tenant_id
WHERE tu.user_id = $1
ORDER BY t.name
`

func (q *Queries) GetTenantsByUser(ctx context.Context, userID int64) ([]Tenant, error) {
	rows, err := q.db.QueryContext(ctx, getTenantsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Name,
			&i.Subdomain,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByTenant = `-- name: GetUsersByTenant :many
SELECT u.id, u.cognito_id, u.email, u.first_name, u.last_name, u.created_at, u.updated_at FROM users u
INNER JOIN tenant_users tu ON u.id = tu.user_id
WHERE tu.tenant_id = $1
ORDER BY u.email
`

func (q *Queries) GetUsersByTenant(ctx context.Context, tenantID int64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CognitoID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantUsers = `-- name: ListTenantUsers :many
SELECT 
    tu.id, tu.tenant_id, tu.user_id, tu.role, tu.created_at, tu.updated_at,
    u.email,
    u.first_name,
    u.last_name
FROM tenant_users tu
INNER JOIN users u ON tu.user_id = u.id
WHERE tu.tenant_id = $1
ORDER BY u.email
`

type ListTenantUsersRow struct {
	ID        int64          `json:"id"`
	TenantID  int64          `json:"tenant_id"`
	UserID    int64          `json:"user_id"`
	Role      sql.NullString `json:"role"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	Email     string         `json:"email"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
}

func (q *Queries) ListTenantUsers(ctx context.Context, tenantID int64) ([]ListTenantUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listTenantUsers, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTenantUsersRow{}
	for rows.Next() {
		var i ListTenantUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromTenant = `-- name: RemoveUserFromTenant :exec
DELETE FROM tenant_users
WHERE tenant_id = $1 AND user_id = $2
`

type RemoveUserFromTenantParams struct {
	TenantID int64 `json:"tenant_id"`
	UserID   int64 `json:"user_id"`
}

func (q *Queries) RemoveUserFromTenant(ctx context.Context, arg RemoveUserFromTenantParams) error {
	_, err := q.db.ExecContext(ctx, removeUserFromTenant, arg.TenantID, arg.UserID)
	return err
}

const updateUserRoleInTenant = `-- name: UpdateUserRoleInTenant :one
UPDATE tenant_users
SET role = $3,
    updated_at = NOW()
WHERE tenant_id = $1 AND user_id = $2
RETURNING id, tenant_id, user_id, role, created_at, updated_at
`

type UpdateUserRoleInTenantParams struct {
	TenantID int64          `json:"tenant_id"`
	UserID   int64          `json:"user_id"`
	Role     sql.NullString `json:"role"`
}

func (q *Queries) UpdateUserRoleInTenant(ctx context.Context, arg UpdateUserRoleInTenantParams) (TenantUser, error) {
	row := q.db.QueryRowContext(ctx, updateUserRoleInTenant, arg.TenantID, arg.UserID, arg.Role)
	var i TenantUser
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
